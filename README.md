# ModelFlow
A Python toolkit to manage (time series) models

## Why?
Specify very large (or small) models as concise and intuitive equations. The program to calculate/solve the model is automatic generated. The user don't have to do the household chores.

Large models. Models with many banks and granular data can get very large. 1 million equation and more can be handled.

Agile model development Model are specified at a high level of abstraction and are processed fast. Also solving/calculating models are fast. This makes experiments with model specification agile and fast.

Get rid of models models implemented in Excel. Large models in Excel are difficult to maintain, revise and quality check. Excel is also very slow in calculating models. Moreover Excel don't handle models with contemporaneous feedback well.

Onboarding models and combining from different sources. Creating a Macro prudential model often entails recycling several models specified in different ways: Excel, Latex, Dynare, Python or other languages. Python's ecosystem makes it possible to transform many different models into ModelFlow models or to wrap them into functions which can be called from ModelFlow models.

Onboarding data from different sources. Pythons Pandas Library and other tools are fast and efficient for data management.

A rich set of analytical tools for model and result analytic helps to understand the model and its results.

The user can extend and modify the tools to her or his needs. All code is in Python and the core is quite small.

The main purpose of ModelFlow is to bring a model and a data set together. Then the model can be solved, and the results analysed and
compared. The user can do this either with the Python methods that ModelFlow will wrap around the model, or by by using tools from the Python ecosystem. 

**Models can be specified in a high level Business logic language (a Domain Specific language)**. This allows the formulation of a model in a concise and expressive language which is close to the economic of the model. The user can concentrate on the economic or financial content - not the coding of the solution. The code for solving the model is generated by the tool. Then you can *solve the
simultaneous* (or *non-simultaneous* model) in an efficient way. 

Thus a model **flows** through a number of phases, from a formulation in business logic language to a Python program which can solve the model. 

 

If the
model is not initially specified in the Business logic language, Python
offers a wide range of possibilities to grab a model and transform it to
the Business logic language. Also, models in the form of Matlab
functions can be wrapped and called from ModelFlow. This allows for the recycling and integration models sourced from a number of different origins. 

## Introduction 

**ModelFlow is written in Python**. Python comes "batteries included" and is
the basis of a very rich ecosystem, which consists of a wide array of
libraries. ModelFlow is just another library. It supplements the existing
libraries regarding modeling language and solving and allows the use of
Python as a model management framework.

**Data handling and wrangling is done in the Pandas library**. This
library is the Swiss army knife of data science in Python. It can import and export data to most systems and it is very powerful in manipulating and transforming data.
The core
element of Pandas is the *Dataframe*. A Dataframe is a two-dimensional
tabular data structure. Each *column* consists of cells of the same type
-- it can be a number, a string, a matrix or another Python data object.This includes matrices and other dataframes. Each *row is indexed.* The index can basically be any type of variable
including dates, which is especially relevant for economic and financial models.

**ModelFlow gives the user tools for more than solving models**. This
includes:

-   *Visualization* and comparison of results

-   *Integration* of models from different sources

-   *Analyze the logical structure of a model*. By applying graph theory, 
    ModelFlow can find data lineage, find a suitable calculating sequence and trace 
    causes of changes through the calculations.

-   *Inverting* the model to calculating the necessary instruments to
    achieve a desired target.

-   Calculating the *attributions* from input to the results of a model.

-   Calculating the *attribution* from input to the result of each
    formula.

-   Finding and calculating partial *derivatives* of formulas

-   *Integrating user defined python functions* in the Business logic
    language (like optimization, calculating risk weights or to make a matrices consistent with the RAS algorithm  )

-   *Wrap matlab* models so they can be used in the Business logic
    language.

-   *Speed up* solving using "Just in time compilation"

-   Analyze the model structure through tools from graph theory

-   Handle *large models.* 1,000,000 formulas is not a problem.

-   Integrate model management in Jupyter notebooks for *agile and user
    friendly model use*


**The core code of ModelFlow is small and
documented.** Thus it can easily be modified and expanded to the specific need of the user. *ModelFlow is a toolset*. It can handle models, which conform to the tools.

If you need a feature or have a model which can't be handled in ModelFlow,
you are encouraged to improve ModelFlow. Please share the
improvement, other users may have the same need, or can be inspired by
your work.

Also bear in mind that ModelFlow is experimental. It is provided ”as is”, without any representation or warranty of any kind either express or implied.   

## Requirements

You need Python 3.6+ with asssociated libraries. The easy way is to install Anaconda Python [https://www.anaconda.com/distribution](https://www.anaconda.com/distribution)

In addition to the standard packagdes in the Anaconda distribution you need: Graphviz and cvxopt: they can be installed by running a command window from the Anaconda prompt and stating 

`
conda install graphviz
conda install cvxopt 
`

You will find the anaconda prompt by searching "anaconda" in the start menu search field
